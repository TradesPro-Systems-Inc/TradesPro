åŸºäºæœ€ç»ˆç‰ˆV4å·¥ç¨‹è§„èŒƒï¼Œæä¾›å®Œæ•´çš„å®ç°ç»†èŠ‚ã€‚

## ğŸ¯ æœ€ç»ˆç‰ˆV4å®Œæ•´å®ç°

### ç¬¬ä¸€éƒ¨åˆ†ï¼šç»Ÿä¸€ç±»å‹å®šä¹‰

```typescript
// types/cecTypes.ts
export interface CecInputsV3 {
Â  // åŸºæœ¬ä¿¡æ¯
Â  livingArea_m2: number;
Â  systemVoltage: 120 | 208 | 240 | 277 | 480;
Â  phase: 1 | 3;
Â  conductorMaterial: 'Cu' | 'Al';
Â  terminationTempC: 60 | 75 | 90;
Â  ambientTempC: number;
Â  numConductorsInRaceway: number;
Â Â 
Â  // è´Ÿè½½ä¿¡æ¯
Â  heatingLoadW: number;
Â  coolingLoadW: number;
Â  isInterlocked: boolean;
Â  rangeLoadW: number;
Â  evChargerLoadW: number;
Â  // ... å…¶ä»–ç”µå™¨è´Ÿè½½
}

export interface CalculationStep {
Â  stepIndex: number;
Â  operationId: string;
Â  formulaRef: string;
Â  ruleCitations: string[];
Â  inputs: Record<string, any>;
Â  outputs: Record<string, any>;
Â  intermediateValues?: Record<string, any>;
Â  justification: string;
Â  tableReferences?: TableReference[];
Â  warnings?: string[];
Â  timestamp: string;
Â  _hash?: string; // ç¡®å®šæ€§å“ˆå¸Œ
}

export interface TableReference {
Â  tableId: string;
Â  edition: string;
Â  section: string;
Â  lookupValues: Record<string, any>;
Â  result: any;
}

export interface UnsignedBundleV3 {
Â  inputs: CecInputsV3;
Â  results: {
Â  Â  calculatedLoad_w: number;
Â  Â  serviceCurrent_a: number;
Â  Â  sizingCurrent_a: number;
Â  Â  conductorSize: string;
Â  Â  baseAmpacity: number;
Â  Â  deratedAmpacity: number;
Â  };
Â  steps: CalculationStep[];
Â  warnings: string[];
Â  metadata: {
Â  Â  engine: EngineMeta;
Â  Â  calculationMethod: 'cec_8_200';
Â  Â  timestamp: string;
Â  Â  version: string;
Â  };
}
```

### ç¬¬äºŒéƒ¨åˆ†ï¼šçº¯è®¡ç®—æ¨¡å—å®ç°

```typescript
// core/calculators/baseLoadCalculator.ts
export function calculateBaseLoad(livingArea_m2: number): number {
Â  if (livingArea_m2 <= 90) {
Â  Â  return 5000;
Â  }
Â Â 
Â  const additionalArea = livingArea_m2 - 90;
Â  const additionalUnits = Math.ceil(additionalArea / 90);
Â  return 5000 + additionalUnits * 1000;
}
```

```typescript
// core/calculators/heatingCoolingCalculator.ts
export function calculateHeatingCoolingLoad(
Â  heatingLoadW: number,
Â  coolingLoadW: number,
Â  isInterlocked: boolean
): number {
Â  // ä¾›æš–è´Ÿè½½éœ€æ±‚ç³»æ•°è®¡ç®—
Â  const heatingDemand = heatingLoadW <= 10000Â 
Â  Â  ? heatingLoadWÂ 
Â  Â  : 10000 + (heatingLoadW - 10000) * 0.75;
Â Â 
Â  // äº¤äº’è§„åˆ™å¤„ç†
Â  if (isInterlocked && heatingLoadW > 0 && coolingLoadW > 0) {
Â  Â  return Math.max(heatingDemand, coolingLoadW);
Â  }
Â Â 
Â  return heatingDemand + coolingLoadW;
}
```

```typescript
// core/calculators/conductorSelector.ts
import { RuleTablesV3, TableReference } from '../../types/cecTypes';

export interface ConductorSelectionResult {
Â  size: string;
Â  baseAmpacity: number;
Â  deratedAmpacity: number;
Â  tableRefs: TableReference[];
Â  warnings: string[];
}

export function selectConductor(
Â  requiredCurrent: number,
Â  material: 'Cu' | 'Al',
Â  terminationTempC: 60 | 75 | 90,
Â  ambientTempC: number,
Â  numConductorsInRaceway: number,
Â  ruleTables: RuleTablesV3
): ConductorSelectionResult {
Â  const tableRefs: TableReference[] = [];
Â  const warnings: string[] = [];
Â Â 
Â  // 1. ç¡®å®šåŸºç¡€è½½æµé‡è¡¨æ ¼
Â  const baseAmpacityTable = material === 'Cu'Â 
Â  Â  ? ruleTables.table2.copperÂ 
Â  Â  : ruleTables.table2.aluminum;
Â Â 
Â  // 2. æŸ¥æ‰¾æ¸©åº¦ä¿®æ­£ç³»æ•°
Â  const tempCorrectionTable = ruleTables.table5A;
Â  const tempCorrectionFactor = findTemperatureCorrection(
Â  Â  tempCorrectionTable,Â 
Â  Â  ambientTempC,Â 
Â  Â  terminationTempC
Â  );
Â Â 
Â  tableRefs.push({
Â  Â  tableId: '5A',
Â  Â  edition: '2024',
Â  Â  section: '4-004',
Â  Â  lookupValues: { ambientTempC, terminationTempC },
Â  Â  result: tempCorrectionFactor
Â  });
Â Â 
Â  // 3. æŸ¥æ‰¾å¯¼çº¿æŸä¿®æ­£ç³»æ•°
Â  const bundleCorrectionTable = ruleTables.table5C;
Â  const bundleCorrectionFactor = findBundleCorrection(
Â  Â  bundleCorrectionTable,
Â  Â  numConductorsInRaceway
Â  );
Â Â 
Â  tableRefs.push({
Â  Â  tableId: '5C',Â 
Â  Â  edition: '2024',
Â  Â  section: '4-004',
Â  Â  lookupValues: { numConductorsInRaceway },
Â  Â  result: bundleCorrectionFactor
Â  });
Â Â 
Â  // 4. é€‰æ‹©æœ€å°åˆé€‚å¯¼çº¿å°ºå¯¸
Â  let selectedSize = '';
Â  let baseAmpacity = 0;
Â  let deratedAmpacity = 0;
Â Â 
Â  // ä½¿ç”¨ç¨³å¥çš„å¯¼çº¿å°ºå¯¸æ¯”è¾ƒç®—æ³•
Â  const wireSizes = Object.keys(baseAmpacityTable).sort(compareWireSizes);
Â Â 
Â  for (const size of wireSizes) {
Â  Â  baseAmpacity = baseAmpacityTable[size];
Â  Â  deratedAmpacity = baseAmpacity * tempCorrectionFactor * bundleCorrectionFactor;
Â  Â Â 
Â  Â  if (deratedAmpacity >= requiredCurrent) {
Â  Â  Â  selectedSize = size;
Â  Â  Â  break;
Â  Â  }
Â  }
Â Â 
Â  if (!selectedSize) {
Â  Â  selectedSize = wireSizes[wireSizes.length - 1]; // æœ€å¤§å¯ç”¨å°ºå¯¸
Â  Â  warnings.push(`No conductor found for ${requiredCurrent}A. Using largest available: ${selectedSize}`);
Â  }
Â Â 
Â  tableRefs.push({
Â  Â  tableId: '2',
Â  Â  edition: '2024',Â 
Â  Â  section: '4-004',
Â  Â  lookupValues: { material, terminationTempC },
Â  Â  result: { size: selectedSize, baseAmpacity }
Â  });
Â Â 
Â  return {
Â  Â  size: selectedSize,
Â  Â  baseAmpacity,
Â  Â  deratedAmpacity,
Â  Â  tableRefs,
Â  Â  warnings
Â  };
}

// ç¨³å¥çš„å¯¼çº¿å°ºå¯¸æ¯”è¾ƒå‡½æ•°
function compareWireSizes(a: string, b: string): number {
Â  const sizeOrder = ['14', '12', '10', '8', '6', '4', '3', '2', '1',Â 
Â  Â  '1/0', '2/0', '3/0', '4/0', '250', '300', '350', '400', '500', '600'];
Â Â 
Â  return sizeOrder.indexOf(a) - sizeOrder.indexOf(b);
}
```

### ç¬¬ä¸‰éƒ¨åˆ†ï¼šè¡¨æ ¼åŠ è½½å™¨ï¼ˆå”¯ä¸€I/Oæ¥æºï¼‰

```typescript
// core/tables/tableLoader.ts
import { RuleTablesV3 } from '../../types/cecTypes';

// åœ¨æ„å»ºæ—¶é™æ€å¯¼å…¥è¡¨æ ¼æ•°æ®
import table2Data from './data/table2.json';
import table5AData from './data/table5A.json';
import table5CData from './data/table5C.json';

export function loadAllRuleTables(
Â  code: 'cec' | 'nec' = 'cec',
Â  edition: string = '2024'
): RuleTablesV3 {
Â  // è¿™é‡Œå¯ä»¥åŸºäºcodeå’ŒeditionåŠ è½½ä¸åŒç‰ˆæœ¬çš„è¡¨æ ¼
Â  // ä½†ç›®å‰æˆ‘ä»¬ä½¿ç”¨é™æ€å¯¼å…¥ç¡®ä¿æ— è¿è¡Œæ—¶I/O
Â Â 
Â  return {
Â  Â  table2: table2Data,
Â  Â  table5A: table5AData,
Â  Â  table5C: table5CData,
Â  Â  // ... å…¶ä»–è¡¨æ ¼
Â  };
}
```

### ç¬¬å››éƒ¨åˆ†ï¼šæœ€ç»ˆçš„å®¡è®¡åè°ƒå™¨

```typescript
// services/calculateCecLoad_V4.ts
import { calculateBaseLoad } from '../core/calculators/baseLoadCalculator';
import { calculateHeatingCoolingLoad } from '../core/calculators/heatingCoolingCalculator';
import { selectConductor } from '../core/calculators/conductorSelector';
import { loadAllRuleTables } from '../core/tables/tableLoader';
import {Â 
Â  CecInputsV3,Â 
Â  UnsignedBundleV3,Â 
Â  CalculationStep,
Â  EngineMetaÂ 
} from '../types/cecTypes';

export function calculateCecLoad_V4(
Â  inputs: CecInputsV3,Â 
Â  engineMeta: EngineMeta
): UnsignedBundleV3 {
Â  const steps: CalculationStep[] = [];
Â  let stepIndex = 1;
Â  const createdAt = new Date().toISOString();
Â  const warnings: string[] = [];
Â Â 
Â  // *** å…³é”®ï¼šåœ¨åè°ƒå™¨é¡¶å±‚ä¸€æ¬¡æ€§åŠ è½½æ‰€æœ‰è¡¨æ ¼ ***
Â  const ruleTables = loadAllRuleTables('cec', '2024');

Â  // --- æ­¥éª¤1: åŸºç¡€è´Ÿè½½è®¡ç®— ---
Â  const baseLoadW = calculateBaseLoad(inputs.livingArea_m2);
Â  steps.push({
Â  Â  stepIndex: stepIndex++,
Â  Â  operationId: 'calc_base_load',
Â  Â  formulaRef: 'CEC 8-200 1)a)i),ii)',
Â  Â  ruleCitations: ['8-200 1)a)i)', '8-200 1)a)ii)'],
Â  Â  inputs: { livingArea_m2: inputs.livingArea_m2 },
Â  Â  outputs: { basicLoad_W: baseLoadW },
Â  Â  intermediateValues: inputs.livingArea_m2 > 90 ? {
Â  Â  Â  additionalArea: inputs.livingArea_m2 - 90,
Â  Â  Â  additionalUnits: Math.ceil((inputs.livingArea_m2 - 90) / 90)
Â  Â  } : undefined,
Â  Â  justification: inputs.livingArea_m2 <= 90Â 
Â  Â  Â  ? '5000W for dwelling units up to 90mÂ²'Â 
Â  Â  Â  : '5000W for first 90mÂ² + 1000W per additional 90mÂ² portion',
Â  Â  timestamp: createdAt,
Â  });

Â  let totalLoadW = baseLoadW;

Â  // --- æ­¥éª¤2: ä¾›æš–ç©ºè°ƒè´Ÿè½½è®¡ç®— ---
Â  const hvacW = calculateHeatingCoolingLoad(
Â  Â  inputs.heatingLoadW,
Â  Â  inputs.coolingLoadW,Â 
Â  Â  inputs.isInterlocked
Â  );
Â Â 
Â  const heatingDemand = inputs.heatingLoadW <= 10000Â 
Â  Â  ? inputs.heatingLoadWÂ 
Â  Â  : 10000 + (inputs.heatingLoadW - 10000) * 0.75;
Â Â 
Â  steps.push({
Â  Â  stepIndex: stepIndex++,
Â  Â  operationId: 'calc_heating_ac_load',
Â  Â  formulaRef: 'CEC 8-200 1)a)iii), 62-118 3), 8-106 3)',
Â  Â  ruleCitations: ['8-200 1)a)iii)', '62-118 3)', '8-106 3)'],
Â  Â  inputs: {Â 
Â  Â  Â  heatingLoadW: inputs.heatingLoadW,Â 
Â  Â  Â  coolingLoadW: inputs.coolingLoadW,Â 
Â  Â  Â  isInterlocked: inputs.isInterlockedÂ 
Â  Â  },
Â  Â  outputs: { heatingAcLoad_W: hvacW },
Â  Â  intermediateValues: {
Â  Â  Â  heatingDemandFactor: inputs.heatingLoadW > 10000 ? '100% of first 10kW + 75% of excess' : '100%',
Â  Â  Â  calculatedHeatingDemand: heatingDemand,
Â  Â  Â  interlockEffect: inputs.isInterlocked ? 'Using greater of heating or cooling' : 'Sum of heating and cooling'
Â  Â  },
Â  Â  justification: 'Heating load with demand factor per CEC 62-118, AC load at 100%, interlock rule per CEC 8-106',
Â  Â  timestamp: createdAt,
Â  });
Â Â 
Â  totalLoadW += hvacW;

Â  // --- æ­¥éª¤3: å…¶ä»–è´Ÿè½½è®¡ç®— (èŒƒå›´ã€EVç­‰) ---
Â  // [è¿™é‡Œæ·»åŠ å…¶ä»–çº¯è®¡ç®—æ¨¡å—çš„è°ƒç”¨å’Œå®¡è®¡æ­¥éª¤è®°å½•]
Â Â 
Â  // --- æ­¥éª¤4: æœåŠ¡ç”µæµè®¡ç®— ---
Â  const serviceCurrentA = totalLoadW / inputs.systemVoltage;
Â  steps.push({
Â  Â  stepIndex: stepIndex++,
Â  Â  operationId: 'calc_service_current',
Â  Â  formulaRef: 'I = P / V',
Â  Â  ruleCitations: [],
Â  Â  inputs: { totalLoad_W: totalLoadW, systemVoltage_V: inputs.systemVoltage },
Â  Â  outputs: { serviceCurrent_A: serviceCurrentA },
Â  Â  justification: `Service current = Total load ${totalLoadW}W / System voltage ${inputs.systemVoltage}V`,
Â  Â  timestamp: createdAt,
Â  });

Â  // --- æ­¥éª¤5: å¯¼çº¿é€‰æ‹© ---
Â  const sizingCurrentA = serviceCurrentA * 1.25; // 125% è¿ç»­è´Ÿè½½ç³»æ•°
Â Â 
Â  const conductorResult = selectConductor(
Â  Â  sizingCurrentA,
Â  Â  inputs.conductorMaterial,
Â  Â  inputs.terminationTempC,
Â  Â  inputs.ambientTempC,
Â  Â  inputs.numConductorsInRaceway,
Â  Â  ruleTables
Â  );
Â Â 
Â  steps.push({
Â  Â  stepIndex: stepIndex++,
Â  Â  operationId: 'select_conductor',
Â  Â  formulaRef: 'CEC Table 2, 5A, 5C - 4-004',
Â  Â  ruleCitations: ['4-004', 'Table 2', 'Table 5A', 'Table 5C'],
Â  Â  inputs: {Â 
Â  Â  Â  sizingCurrent_A: sizingCurrentA,
Â  Â  Â  material: inputs.conductorMaterial,
Â  Â  Â  terminationTempC: inputs.terminationTempC,
Â  Â  Â  ambientTempC: inputs.ambientTempC,
Â  Â  Â  numConductorsInRaceway: inputs.numConductorsInRaceway
Â  Â  },
Â  Â  outputs: {Â 
Â  Â  Â  conductorSize: conductorResult.size,
Â  Â  Â  baseAmpacity: conductorResult.baseAmpacity,
Â  Â  Â  deratedAmpacity: conductorResult.deratedAmpacity
Â  Â  },
Â  Â  intermediateValues: {
Â  Â  Â  requiredCurrent: sizingCurrentA,
Â  Â  Â  temperatureFactor: conductorResult.deratedAmpacity / conductorResult.baseAmpacity,
Â  Â  Â  bundleFactor: 1.0 // ä»tableRefsä¸­å¯ä»¥æ¨å¯¼
Â  Â  },
Â  Â  justification: 'Smallest conductor where Derated Ampacity (Base Ã— Temp Factor Ã— Bundle Factor) â‰¥ Sizing Current',
Â  Â  timestamp: createdAt,
Â  Â  tableReferences: conductorResult.tableRefs,
Â  Â  warnings: conductorResult.warnings
Â  });
Â Â 
Â  warnings.push(...conductorResult.warnings);

Â  // --- ç»„è£…æœ€ç»ˆç»“æœåŒ… ---
Â  const finalBundle: UnsignedBundleV3 = {
Â  Â  inputs,
Â  Â  results: {
Â  Â  Â  calculatedLoad_w: totalLoadW,
Â  Â  Â  serviceCurrent_a: serviceCurrentA,
Â  Â  Â  sizingCurrent_a: sizingCurrentA,
Â  Â  Â  conductorSize: conductorResult.size,
Â  Â  Â  baseAmpacity: conductorResult.baseAmpacity,
Â  Â  Â  deratedAmpacity: conductorResult.deratedAmpacity
Â  Â  },
Â  Â  steps,
Â  Â  warnings,
Â  Â  metadata: {
Â  Â  Â  engine: engineMeta,
Â  Â  Â  calculationMethod: 'cec_8_200',
Â  Â  Â  timestamp: createdAt,
Â  Â  Â  version: '4.0.0'
Â  Â  }
Â  };

Â  return finalBundle;
}
```

### ç¬¬äº”éƒ¨åˆ†ï¼šæµ‹è¯•ç­–ç•¥

```typescript
// tests/unit/calculators/baseLoadCalculator.spec.ts
import { calculateBaseLoad } from '../../../core/calculators/baseLoadCalculator';

describe('BaseLoadCalculator', () => {
Â  it('should return 5000W for exactly 90mÂ²', () => {
Â  Â  expect(calculateBaseLoad(90)).toBe(5000);
Â  });

Â  it('should return 6000W for 180mÂ²', () => {
Â  Â  expect(calculateBaseLoad(180)).toBe(6000);
Â  });

Â  it('should handle fractional areas correctly', () => {
Â  Â  expect(calculateBaseLoad(91)).toBe(6000); // å‘ä¸Šå–æ•´
Â  Â  expect(calculateBaseLoad(179)).toBe(6000); // ä»ç„¶æ˜¯ä¸€ä¸ªé¢å¤–å•ä½
Â  });
});

// tests/integration/cecCalculation.spec.ts
import { calculateCecLoad_V4 } from '../../../services/calculateCecLoad_V4';

describe('CEC 8-200 Full Calculation', () => {
Â  const standardInputs: CecInputsV3 = {
Â  Â  livingArea_m2: 120,
Â  Â  systemVoltage: 240,
Â  Â  phase: 1,
Â  Â  conductorMaterial: 'Cu',
Â  Â  terminationTempC: 75,
Â  Â  ambientTempC: 30,
Â  Â  numConductorsInRaceway: 3,
Â  Â  heatingLoadW: 8000,
Â  Â  coolingLoadW: 5000,
Â  Â  isInterlocked: true,
Â  Â  rangeLoadW: 8000,
Â  Â  evChargerLoadW: 0
Â  };

Â  it('should produce correct total load', () => {
Â  Â  const result = calculateCecLoad_V4(standardInputs, testEngineMeta);
Â  Â Â 
Â  Â  expect(result.results.calculatedLoad_w).toBe(19000); // æ ¹æ®å…·ä½“è®¡ç®—éªŒè¯
Â  Â  expect(result.steps).toHaveLength(5); // æ ¹æ®å®é™…æ­¥éª¤æ•°è°ƒæ•´
Â  });

Â  it('should include complete audit trail', () => {
Â  Â  const result = calculateCecLoad_V4(standardInputs, testEngineMeta);
Â  Â Â 
Â  Â  // éªŒè¯å®¡è®¡æ­¥éª¤çš„å®Œæ•´æ€§
Â  Â  expect(result.steps[0].operationId).toBe('calc_base_load');
Â  Â  expect(result.steps[0].tableReferences).toBeUndefined(); // åŸºç¡€è´Ÿè½½æ²¡æœ‰è¡¨æ ¼å¼•ç”¨
Â  Â  expect(result.steps[4].tableReferences).toBeDefined(); // å¯¼çº¿é€‰æ‹©æœ‰è¡¨æ ¼å¼•ç”¨
Â  Â  expect(result.steps[4].tableReferences!.length).toBeGreaterThan(0);
Â  });
});
```