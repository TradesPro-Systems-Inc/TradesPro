# backend/app/utils/signing.py
# Bundle Signing - V4.1 Architecture Trust Anchor
#
# This module provides cryptographic signing for calculation bundles.
# Signing ensures:
# 1. Integrity: Bundle has not been tampered with
# 2. Authenticity: Bundle was generated by the trusted backend
# 3. Non-repudiation: Cannot deny that the calculation was performed
#
# According to V4.1 architecture, only backend-generated bundles can be signed.

from datetime import datetime
from typing import Dict, Any, Optional, Union
import hashlib
import hmac
import json
import unicodedata
import decimal

from .config import settings


class BundleSigner:
    """
    V4.1 Bundle Signer
    
    Provides cryptographic signing for calculation bundles.
    Uses HMAC-SHA256 for signing (can be upgraded to RSA/ECDSA for production).
    
    Implements RFC 8785 (JSON Canonicalization Scheme) for deterministic serialization.
    """
    
    @staticmethod
    def canonicalize_json(obj: Any) -> str:
        """
        Canonicalize JSON according to RFC 8785 (JSON Canonicalization Scheme).
        
        RFC 8785 Requirements:
        1. Property names are sorted lexicographically
        2. Numbers are normalized (no leading zeros, shortest round-trip form)
        3. Strings are normalized to NFC Unicode
        4. Arrays preserve order (do not sort)
        5. Compact JSON format (no whitespace)
        
        Args:
            obj: Python object to canonicalize
            
        Returns:
            Canonicalized JSON string
        """
        def normalize_value(value: Any) -> Any:
            """Normalize a value according to RFC 8785."""
            if isinstance(value, dict):
                # Sort keys lexicographically and recursively normalize values
                sorted_dict = {}
                for key in sorted(value.keys()):
                    normalized_key = unicodedata.normalize('NFC', str(key))
                    sorted_dict[normalized_key] = normalize_value(value[key])
                return sorted_dict
            elif isinstance(value, list):
                # Preserve array order, normalize each element
                return [normalize_value(item) for item in value]
            elif isinstance(value, (int, float, decimal.Decimal)):
                # Normalize numbers: use shortest round-trip representation
                # For integers, remove any leading zeros
                if isinstance(value, int):
                    return value
                # For floats, use shortest representation
                # This is a simplified approach; full RFC 8785 would require more precision
                return value
            elif isinstance(value, str):
                # Normalize strings to NFC Unicode
                return unicodedata.normalize('NFC', value)
            elif value is None:
                return None
            elif isinstance(value, bool):
                return value
            else:
                # For other types, convert to string and normalize
                return unicodedata.normalize('NFC', str(value))
        
        normalized_obj = normalize_value(obj)
        # Compact JSON (no whitespace, separators without spaces)
        return json.dumps(normalized_obj, separators=(',', ':'), ensure_ascii=False, sort_keys=True)
    
    @staticmethod
    def calculate_root_hash(bundle_data: Dict[str, Any]) -> str:
        """
        Calculate rootHash (SHA-256) of canonicalized bundle according to RFC 8785.
        
        V4.1 Architecture:
        - Uses RFC 8785 canonicalization for deterministic serialization
        - Calculates SHA-256 hash of canonical JSON
        - Returns hexadecimal hash string (prefixed with 'sha256:')
        
        Args:
            bundle_data: Bundle dictionary to hash
            
        Returns:
            Root hash string (format: 'sha256:<hex>')
        """
        # Remove signatures field before canonicalization (signatures are applied to hash, not included)
        canonical_target = {k: v for k, v in bundle_data.items() if k != 'signature' and k != 'is_signed' and k != 'signed_at' and k != 'signed_by'}
        
        # Canonicalize according to RFC 8785
        canonical_json = BundleSigner.canonicalize_json(canonical_target)
        
        # Calculate SHA-256 hash
        hash_hex = hashlib.sha256(canonical_json.encode('utf-8')).hexdigest()
        
        # Return with 'sha256:' prefix (per V4.1 spec)
        return f'sha256:{hash_hex}'
    
    @staticmethod
    def get_signing_key() -> str:
        """
        Get the signing key from settings.
        
        Returns:
            Signing key string
            
        Raises:
            ValueError: If signing key is not configured
        """
        signing_key = getattr(settings, 'BUNDLE_SIGNING_KEY', None)
        if not signing_key or signing_key == settings.SECRET_KEY:
            # Fallback to SECRET_KEY if no dedicated signing key
            signing_key = settings.SECRET_KEY
        
        if not signing_key or signing_key.startswith('change-this'):
            raise ValueError(
                "Bundle signing key not configured. "
                "Set BUNDLE_SIGNING_KEY in environment variables for production."
            )
        
        return signing_key
    
    @staticmethod
    def calculate_bundle_hash(bundle_data: Dict[str, Any]) -> str:
        """
        Calculate SHA-256 hash of bundle for integrity verification.
        
        DEPRECATED: Use calculate_root_hash() instead for RFC 8785 compliance.
        This method is kept for backward compatibility.
        
        Args:
            bundle_data: Bundle dictionary (must be JSON-serializable)
            
        Returns:
            Hexadecimal hash string (without 'sha256:' prefix for compatibility)
        """
        # Use RFC 8785 canonicalization
        root_hash = BundleSigner.calculate_root_hash(bundle_data)
        # Return without prefix for backward compatibility
        return root_hash.replace('sha256:', '')
    
    @staticmethod
    def sign_bundle(
        bundle_data: Dict[str, Any],
        user_id: int,
        user_email: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Sign a calculation bundle with HMAC-SHA256.
        
        Args:
            bundle_data: Bundle dictionary to sign
            user_id: ID of user executing the calculation
            user_email: Email of user (optional, for audit trail)
            
        Returns:
            Bundle dictionary with signature added
        """
        signing_key = BundleSigner.get_signing_key()
        
        # V4.1 Architecture: Calculate rootHash using RFC 8785 canonicalization
        # First, ensure bundle_hash is set (calculate if not present)
        if not bundle_data.get('bundle_hash') or not bundle_data.get('bundle_hash').startswith('sha256:'):
            bundle_data['bundle_hash'] = BundleSigner.calculate_root_hash(bundle_data)
        
        # Create signature payload (exclude any existing signature)
        # The rootHash is the canonical representation of the bundle
        signature_payload = {
            'rootHash': bundle_data.get('bundle_hash'),  # Use rootHash in signature payload
            'id': bundle_data.get('id'),
            'engine_version': bundle_data.get('engine_version'),
            'engine_commit': bundle_data.get('engine_commit'),
        }
        
        # Canonicalize signature payload according to RFC 8785
        canonical_payload = BundleSigner.canonicalize_json(signature_payload)
        
        # Calculate signature over canonicalized payload
        signature = hmac.new(
            signing_key.encode('utf-8'),
            canonical_payload.encode('utf-8'),
            hashlib.sha256
        ).hexdigest()
        
        # Create signature metadata (V4.1 Architecture)
        signature_data = {
            'algorithm': 'HMAC-SHA256',  # For production, use ES256 or PS256
            'rootHash': bundle_data.get('bundle_hash'),
            'signature': signature,
            'signed_at': datetime.utcnow().isoformat(),
            'signed_by_user_id': user_id,
            'signed_by_email': user_email,
            'signed_by': f'backend-coordinator (user_id: {user_id})',
            'canonicalization': 'RFC8785'  # Document the canonicalization method used
        }
        
        # Add signature to bundle
        bundle_data['signature'] = signature_data
        bundle_data['is_signed'] = True
        bundle_data['signed_at'] = signature_data['signed_at']
        bundle_data['signed_by'] = signature_data['signed_by']
        
        return bundle_data
    
    @staticmethod
    def verify_bundle_signature(bundle_data: Dict[str, Any]) -> bool:
        """
        Verify the signature of a calculation bundle.
        
        Args:
            bundle_data: Bundle dictionary with signature
            
        Returns:
            True if signature is valid, False otherwise
        """
        if not bundle_data.get('is_signed'):
            return False
        
        signature_data = bundle_data.get('signature')
        if not signature_data or not isinstance(signature_data, dict):
            return False
        
        original_signature = signature_data.get('signature')
        if not original_signature:
            return False
        
        # Extract signature metadata
        signed_by_user_id = signature_data.get('signed_by_user_id')
        
        # Recreate signature payload (must match what was signed)
        signature_payload = {
            'rootHash': bundle_data.get('bundle_hash') or bundle_data.get('signature', {}).get('rootHash'),
            'id': bundle_data.get('id'),
            'engine_version': bundle_data.get('engine_version'),
            'engine_commit': bundle_data.get('engine_commit'),
        }
        
        # Canonicalize signature payload according to RFC 8785
        signing_key = BundleSigner.get_signing_key()
        canonical_payload = BundleSigner.canonicalize_json(signature_payload)
        expected_signature = hmac.new(
            signing_key.encode('utf-8'),
            canonical_payload.encode('utf-8'),
            hashlib.sha256
        ).hexdigest()
        
        # Compare signatures (constant-time comparison to prevent timing attacks)
        return hmac.compare_digest(original_signature, expected_signature)

