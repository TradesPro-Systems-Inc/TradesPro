# backend/app/models/calculation.py
# Calculation Model - Store calculation bundles from shared engine

from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Text, Boolean
from sqlalchemy.dialects.postgresql import JSONB
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from ..database import Base


class Calculation(Base):
    """
    Calculation model for storing calculation bundles.
    
    This model stores the UnsignedBundle generated by the shared calculation engine.
    It does NOT contain calculation logic - that's in @tradespro/calculation-engine.
    
    Relationships:
    - project: Many-to-one with Project
    - user: Through project.owner
    """
    __tablename__ = "calculations"
    
    # Primary Key (bundle_id from calculation engine)
    id = Column(String(36), primary_key=True)
    
    # Foreign Keys
    project_id = Column(Integer, ForeignKey("projects.id", ondelete="CASCADE"), nullable=False, index=True)
    
    # Calculation Metadata
    building_type = Column(String(50), nullable=False, index=True)  # single-dwelling, apartment, etc.
    calculation_type = Column(String(50), nullable=False, default="cec_load", index=True)
    
    # Code Version
    code_edition = Column(String(10), nullable=False, default="2024", index=True)
    code_type = Column(String(10), nullable=False, default="cec")
    
    # Complete Calculation Bundle (JSONB for indexing)
    inputs = Column(JSONB, nullable=False)
    results = Column(JSONB, nullable=False)
    steps = Column(JSONB, nullable=False)
    warnings = Column(JSONB, nullable=True)
    
    # Engine Metadata
    engine_version = Column(String(50), nullable=True)
    engine_commit = Column(String(64), nullable=True)
    
    # Bundle Integrity
    # Note: sha256:<64-hex-chars> = 71 characters, so we use 128 for safety
    bundle_hash = Column(String(128), nullable=True)
    
    # Signing (future feature)
    is_signed = Column(Boolean, default=False, nullable=False, index=True)
    signature = Column(JSONB, nullable=True)
    signed_at = Column(DateTime(timezone=True), nullable=True)
    signed_by = Column(String(200), nullable=True)
    
    # Timestamps
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False, index=True)
    calculation_time_ms = Column(Integer, nullable=True)
    
    # Soft Delete
    deleted_at = Column(DateTime(timezone=True), nullable=True, index=True)
    
    # Relationships
    project = relationship("Project", back_populates="calculations")
    
    def __repr__(self):
        return f"<Calculation(id={self.id}, building_type='{self.building_type}', project_id={self.project_id})>"
    
    @staticmethod
    def _to_int_or_none(value):
        """Helper to safely convert value to int, handling strings and floats."""
        if value is None:
            return None
        try:
            # Handle string values like "119.11"
            if isinstance(value, str):
                # Try to parse as float first, then round to int
                float_val = float(value)
                return int(round(float_val))
            # Handle float values
            elif isinstance(value, (float, int)):
                return int(round(float(value)))
            # Already an int
            return int(value)
        except (ValueError, TypeError):
            return None
    
    def to_dict(self, include_bundle=True):
        """
        Convert calculation to dictionary.
        
        Args:
            include_bundle: If True, includes full inputs, results, steps, warnings
        """
        data = {
            'id': self.id,
            'project_id': self.project_id,
            'building_type': self.building_type,
            'calculation_type': self.calculation_type,
            'code_edition': self.code_edition,
            'code_type': self.code_type,
            'engine_version': self.engine_version,
            'engine_commit': self.engine_commit,
            'bundle_hash': self.bundle_hash,
            'is_signed': self.is_signed,
            'signed_at': self.signed_at.isoformat() if self.signed_at else None,
            'signed_by': self.signed_by,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'calculation_time_ms': self.calculation_time_ms,
            'deleted_at': self.deleted_at.isoformat() if self.deleted_at else None,
        }
        
        if include_bundle:
            data['inputs'] = self.inputs if isinstance(self.inputs, dict) else {}
            data['results'] = self.results if isinstance(self.results, dict) else {}
            data['steps'] = self.steps if isinstance(self.steps, list) else []
            data['warnings'] = self.warnings if isinstance(self.warnings, list) else []
            if self.is_signed and self.signature:
                data['signature'] = self.signature
        
        # Extract legacy fields from results for backward compatibility
        # Convert to int to match schema requirements
        if isinstance(self.results, dict):
            load_w = self.results.get('chosenCalculatedLoad_W') or self.results.get('calculatedLoadW')
            data['calculated_load_w'] = self._to_int_or_none(load_w)
            
            service_amp = self.results.get('serviceCurrentA') or self.results.get('serviceAmperage')
            data['service_amperage'] = self._to_int_or_none(service_amp)
        
        return data
    
    def get_bundle_data(self):
        """
        Get the complete bundle as a dictionary (for backward compatibility).
        Combines inputs, results, steps, warnings into a single bundle structure.
        """
        return {
            'id': self.id,
            'inputs': self.inputs,
            'results': self.results,
            'steps': self.steps,
            'warnings': self.warnings,
            'metadata': {
                'engine_version': self.engine_version,
                'engine_commit': self.engine_commit,
                'bundle_hash': self.bundle_hash,
                'code_edition': self.code_edition,
                'code_type': self.code_type,
                'calculation_type': self.calculation_type,
                'building_type': self.building_type,
            }
        }



