# backend/app/routes/calculations.py
# Calculation Management Routes

from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.orm import Session
from typing import Optional

from ..database import get_db
from ..models import User
from ..schemas import (
    CalculationCreate, CalculationResponse, CalculationList,
    CalculationListItem, PaginatedResponse, PaginationMeta
)
from ..services.calculation_service import CalculationService
from ..services.calculation_coordinator import CalculationCoordinator
from ..utils.security import get_current_user

router = APIRouter(prefix="/calculations", tags=["calculations"])


@router.post("", response_model=CalculationResponse, status_code=status.HTTP_201_CREATED)
async def create_calculation(
    inputs: dict,
    project_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
    jurisdiction_config: Optional[dict] = None
):
    """
    Create a calculation (V4.1 Architecture).
    
    This endpoint complies with V4.1 specification:
    1. Receives validated CecInputs from frontend (NOT a pre-calculated bundle)
    2. Calls the shared calculation engine via Node.js subprocess
    3. The engine's calculateCecLoad_V4 coordinator orchestrates pure calculation modules
    4. Each calculation completes, coordinator generates a CalculationStep with:
       - inputs: Record<string, any> (required)
       - outputs: Record<string, any> (required)
       - justification: string (required)
       - tableReferences: Array<...> (optional)
    5. Generates trusted audit trail in the backend coordinator
    6. Returns complete UnsignedBundleV4 to frontend
    
    Frontend calculations are for preview only - this is the official, trusted result.
    
    V4.1 Specification Reference:
    - Endpoint: POST /api/v1/calculations
    - Returns: UnsignedBundleV4 (NOT signed)
    - User must review and approve before signing via /sign endpoint
    """
    # Extract jurisdiction config from inputs if provided, or use explicit parameter
    # Frontend can pass jurisdictionConfig in inputs or as separate parameter
    config = jurisdiction_config or inputs.get('jurisdictionConfig')
    
    # Remove jurisdictionConfig from inputs to avoid passing it twice
    if 'jurisdictionConfig' in inputs:
        inputs = {k: v for k, v in inputs.items() if k != 'jurisdictionConfig'}
    
    calculation = CalculationCoordinator.execute_calculation(
        db=db,
        inputs=inputs,
        user_id=current_user.id,
        project_id=project_id,
        jurisdiction_config=config
    )
    return calculation.to_dict(include_bundle=True)


@router.post("/execute", response_model=CalculationResponse, status_code=status.HTTP_201_CREATED)
async def execute_calculation(
    inputs: dict,
    project_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Execute an authoritative calculation with trusted audit trail.
    
    DEPRECATED: Use POST /api/v1/calculations instead (V4.1 specification).
    This endpoint is kept for backward compatibility.
    
    This endpoint will be removed in a future version.
    Please use POST /api/v1/calculations for new integrations.
    """
    # Extract jurisdiction config from inputs if provided, or use explicit parameter
    # Frontend can pass jurisdictionConfig in inputs or as separate parameter
    config = jurisdiction_config or inputs.get('jurisdictionConfig')
    
    # Remove jurisdictionConfig from inputs to avoid passing it twice
    if 'jurisdictionConfig' in inputs:
        inputs = {k: v for k, v in inputs.items() if k != 'jurisdictionConfig'}
    
    calculation = CalculationCoordinator.execute_calculation(
        db=db,
        inputs=inputs,
        user_id=current_user.id,
        project_id=project_id,
        jurisdiction_config=config
    )
    return calculation.to_dict(include_bundle=True)


@router.post("/sync", response_model=CalculationResponse, status_code=status.HTTP_201_CREATED)
async def sync_calculation(
    calc_data: CalculationCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Sync a calculation to the cloud (legacy endpoint).
    
    This endpoint stores the calculation bundle generated by the frontend.
    It does NOT perform calculations - use /execute for authoritative calculations.
    
    Note: This endpoint exists for backward compatibility but should not be used
    for new calculations. Use /execute instead for trusted, auditable results.
    """
    calculation = CalculationService.create_calculation(db, calc_data, current_user.id)
    return calculation


@router.get("", response_model=CalculationList)
async def list_calculations(
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=100),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    List user's calculations across all projects.
    
    Note: This endpoint returns list items without full bundle_data for performance.
    Use the detail endpoint to get the complete bundle.
    """
    from ..models import Calculation, Project
    from sqlalchemy import select
    
    # Get user's project IDs
    user_projects = db.query(Project).filter(Project.owner_id == current_user.id).all()
    project_ids = [p.id for p in user_projects]
    
    if not project_ids:
        return {"calculations": [], "total": 0}
    
    # Get calculations (exclude soft-deleted)
    calculations = db.query(Calculation).filter(
        Calculation.project_id.in_(project_ids),
        Calculation.deleted_at.is_(None)  # Exclude soft-deleted
    ).order_by(Calculation.created_at.desc()).offset(skip).limit(limit).all()
    
    # Get total (exclude soft-deleted)
    total = db.query(Calculation).filter(
        Calculation.project_id.in_(project_ids),
        Calculation.deleted_at.is_(None)
    ).count()
    
    return {
        "calculations": [calc.to_dict(include_bundle=False) for calc in calculations],
        "total": total
    }


@router.get("/{calc_id}", response_model=CalculationResponse)
async def get_calculation(
    calc_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Get calculation by bundle ID (includes full bundle_data).
    """
    calculation = CalculationService.get_calculation_by_id(db, calc_id, current_user.id)
    return calculation.to_dict(include_bundle=True)


@router.delete("/{calc_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_calculation(
    calc_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Delete a calculation (soft delete).
    """
    CalculationService.delete_calculation(db, calc_id, current_user.id)
    return None


@router.get("/by-bundle/{bundle_id}", response_model=CalculationResponse)
async def get_calculation_by_bundle_id(
    bundle_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Get calculation by bundle_id (includes full bundle_data).
    """
    calculation = CalculationService.get_calculation_by_bundle_id(db, bundle_id, current_user.id)
    return calculation.to_dict(include_bundle=True)


@router.post("/{calc_id}/sign", response_model=CalculationResponse, status_code=status.HTTP_200_OK)
async def sign_calculation(
    calc_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Sign a calculation bundle after user approval.
    
    V4.1 Architecture:
    - This endpoint is called AFTER user reviews the UnsignedBundle
    - Performs RFC 8785 canonicalization
    - Calculates rootHash (SHA-256 of canonical JSON)
    - Signs the rootHash with backend signing key
    - Creates an immutable, auditable SignedBundle
    
    This endpoint should only be called after user has:
    1. Reviewed the calculation results
    2. Verified the audit trail (steps)
    3. Approved the calculation for official use
    
    Returns:
        Signed Calculation object
    """
    calculation = CalculationCoordinator.sign_calculation(
        db=db,
        calculation_id=calc_id,
        user_id=current_user.id
    )
    return calculation.to_dict(include_bundle=True)


